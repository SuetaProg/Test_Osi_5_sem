// Массив вопросов из вашего PDF

const questions = [
    {
        question: "Протоколы какого уровня OSI работают в режиме мультиплексиирования ? ",
        options: [
            "физический ",
            "транспортный ",
            "канальный ",
            "сетевой  "
        ],
        correct: 1,
        type: "single",
        explanation: " "
    },

    //{
    //    question: " ",
    //    options: [
    //        " ",
    //        " ",
    //        " ",
    //        " "
    //    ],
    //    correct: 3,
    //    explanation: " "
    //},

    {
        question: "Фильтрация кадров в коммутаторе - это ... ",
        options: [
            "передача кадров из входного буфера в выходной буфер порта , подключенного к сегменту сети отправителя. ",
            "передача кадров из входного буфера в выходной буфер порта , подключенного к сегменту сети получателяю. ",
            "удаление кадров из входного буфера , если адресс получателя и адресс отправителя находятся в разных сегментах сети. ",
            "удаление кадров из входного буфера , если адресс получателя и адресс отправителя находятся в одном сегменте сети. "
        ],
        correct: 3,
        type: "single",
        explanation: " "
    },

    {
        "question": "Какой из протоколов не исправляет ошибки, возникающие при передаче данных?",
        "options": [
            "ICMP",
            "UDP",
            "TCP"
        ],
        "correct": 1,
        type: "single",
        "explanation": "UDP (User Datagram Protocol) является транспортным протоколом без установления соединения и не обеспечивает механизмов повторной передачи или исправления ошибок. Он отправляет данные без гарантии их доставки или целостности. В отличие от него, TCP использует подтверждения и повторные передачи для исправления ошибок, а ICMP в основном используется для служебных сообщений и диагностики."
    },

    {
        "question": "Верно ли, что один поток может устанавливать замок на определенный участок кода несколько раз?",
        "options": [
            "Верно",
            "Неверно"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Это утверждение верно для реентерабельных (повторно входимых) мьютексов (Reentrant mutexes, например, ReentrantLock в Java). Такой мьютекс позволяет одному и тому же потоку захватывать блокировку несколько раз, не блокируя себя. Однако стандартные (нереентерабельные) мьютексы этого не позволяют: повторная попытка захвата тем же потоком приведет к взаимоблокировке (deadlock). Вопрос, вероятно, подразумевает общий случай, где это возможно, поэтому ответ «Верно»."
    },

    {
        "question": "IP-пакет от источника до получателя проходит 5 промежуточных маршрутизаторов, сколько раз вычисляется его контрольная сумма?",
        "options": [
            "5",
            "6",
            "1",
            "10"
        ],
        "correct": 1,
        type: "single",
        "explanation": "Контрольная сумма заголовка IP-пакета вычисляется заново на каждом маршрутизаторе, потому что при каждой пересылке поле TTL (Time To Live) уменьшается на 1, что изменяет заголовок. Исходный отправитель вычисляет её 1 раз. Затем каждый из 5 маршрутизаторов вычисляет её заново перед отправкой следующему узлу. Итого: 1 (источник) + 5 (маршрутизаторы) = 6 раз. Получатель проверяет, но не пересчитывает для пересылки."
    },

    {
        "question": "Какое поле IP-дейтаграммы используют программы traceroute и tracert ?",
        "options": [
            "IP-адрес получателя;",
            "контрольная сумма;",
            "время жизни;",
            "размер дейтаграммы;",
            "IP-адрес отправителя;",
            "указанные программы не используют IP-дейтаграмму;"
        ],
        "correct": 2,
        type: "single",
        "explanation": "Программы traceroute (Unix/Linux) и tracert (Windows) используют поле TTL (Time To Live — время жизни) IP-пакета. Они отправляют серию пакетов с последовательно увеличивающимся TTL (начиная с 1). Каждый промежуточный маршрутизатор уменьшает TTL на 1. Когда TTL становится равен 0, маршрутизатор отбрасывает пакет и отправляет обратно ICMP-сообщение об истечении времени жизни. Анализируя адреса отправителей этих ICMP-сообщений, traceroute строит список маршрутизаторов на пути к цели."
    },

    {
        "question": "Ваш компьютер имеет IP-адрес 192.168.100.22/28. Укажите максимальное число узлов Вашей локальной сети",
        "options": [
            "4",
            "14",
            "16",
            "30"
        ],
        "correct": 1,
        type: "single",
        "explanation": "Маска /28 означает, что для адресации хостов в сети остаётся 32 - 28 = 4 бита. Общее количество адресов в подсети: 2⁴ = 16. Из них два адреса являются служебными: первый (адрес сети, 192.168.100.16) и последний (широковещательный, 192.168.100.31). Поэтому максимальное число узлов (хостов) для использования: 16 - 2 = 14."
    },

    {
        "question": "Какой тип сообщения протокола ICMP используется для DOS-атаки ?",
        "options": [
            "подавление источника;",
            "запрос маски;",
            "эхо-запрос;",
            "перенаправление маршрута;",
            "истечение времени дейтаграммы;"
        ],
        "correct": 2,
        type: "single",
        "explanation": "Для DOS-атак (а именно для атаки Smurf или флуда ping-пакетами) чаще всего используется сообщение ICMP Echo Request (эхо-запрос, тип 8), известное как ping. Злоумышленник отправляет огромное количество таких запросов на широковещательный адрес сети, подделав IP-адрес источника (жертвы). Все узлы в сети отвечают жертве эхо-ответами (ICMP Echo Reply), перегружая её канал или ресурсы. Другие типы ICMP (например, перенаправление) также могут быть использованы для атак, но эхо-запрос является классическим и самым распространённым для флуда."
    },

    {
        "question": "Верно ли, что адресные пространства портов TCP и UDP не совпадают?",
        "options": [
            "Верно",
            "Неверно"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Верно. Хотя диапазон допустимых номеров портов (0-65535) для TCP и UDP одинаков, сами адресные пространства (т.е. множества конечных точек) являются независимыми и принадлежат разным протоколам. Например, TCP-порт 53 и UDP-порт 53 — это два разных логических канала, которые могут использоваться одновременно разными процессами (как в DNS). Поэтому утверждение о том, что их адресные пространства не совпадают, является корректным."
    },

    {
        "question": "На пути от отправителя к получателю IP-пакет прошел 5 промежуточных маршрутизаторов. Сколько раз выполнялся расчет контрольной суммы пакета?",
        "options": [
            "шесть;",
            "четыре;",
            "пять;",
            "два;",
            "семь;"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Контрольная сумма заголовка IP-пакета (Header Checksum) должна быть пересчитана на каждом узле, который изменяет заголовок. Отправитель вычисляет её в первый раз. Каждый маршрутизатор уменьшает значение поля TTL (Time To Live) на 1, что является изменением заголовка, поэтому после этого он обязан заново вычислить контрольную сумму перед отправкой пакета дальше. Всего вычислений: 1 (отправитель) + 5 (маршрутизаторы) = 6 раз. Получатель проверяет контрольную сумму, но не пересчитывает её для пересылки."
    },

    {
        "question": "Укажите в числовом виде максимальное количество узлов в сети с маской 255.255.255.248",
        "options": [
            "2",
            "4",
            "6",
            "8",
            "14"
        ],
        "correct": 2,
        type: "single",
        "explanation": "Маска 255.255.255.248 в двоичном виде имеет 29 единиц в старших разрядах (11111111.11111111.11111111.11111000), что соответствует префиксу /29. Для хостов остаётся 32 - 29 = 3 бита. Количество возможных адресов в подсети: 2³ = 8. Из них два служебных адреса: первый (адрес сети) и последний (широковещательный). Максимальное количество узлов (хостов) для использования: 8 - 2 = 6."
    },

    {
        "question": "Служба DHCP предназначена для:",
        "options": [
            "автоматического получения MAC -адреса по IP - адресу узла;",
            "автоматического получения IP-адреса по MAC- адресу узла;",
            "автоматического получения MAC-адресов узлами сети;",
            "автоматического получения доменных адресов узлами сети;",
            "автоматического получения IP-адресов узлами сети;"
        ],
        "correct": 4,
        type: "single",
        "explanation": "DHCP (Dynamic Host Configuration Protocol) — это сетевой протокол, который позволяет устройствам автоматически получать IP-адрес и другие параметры конфигурации (например, маску подсети, адрес шлюза по умолчанию и адреса DNS-серверов) от DHCP-сервера. Он решает задачу централизованного и динамического распределения IP-адресов в сети."
    },

    {
        "question": "Укажите максимальное число единичных разрядов маски в адресе узла локальной сети (в битах):",
        "options": [
            "24",
            "8",
            "16",
            "32",
            "30"
        ],
        "correct": 4,
        type: "single",
        "explanation": "Маска подсети определяет, какие биты IP-адреса относятся к номеру сети, а какие — к номеру узла. В локальной сети для существования узлов (хостов) необходимо как минимум 2 бита для адресации узлов (чтобы можно было выделить адрес сети и широковещательный адрес, и осталось место хотя бы для одного хоста). Следовательно, максимальное количество единичных разрядов (битов сети) в маске для локальной сети равно 30 (префикс /30). При маске /31 (31 единичный разряд) остаётся 1 бит для узлов (2 адреса), что недостаточно для отделения адреса сети и широковещательного адреса в классическом понимании (хотя иногда используется point-to-point). Маска /32 (32 единичных разряда) определяет единственный адрес, который является адресом узла, но не может образовать сеть с другими узлами."
    },

    {
        "question": "Как проверяется на наличие ошибок IP-дейтаграмма ?",
        "options": [
            "по значению контрольной суммы IP-адресов отправителя и получателя;",
            "IP-дейтаграмма не проверяется на наличие ошибок;",
            "по значению контрольной суммы заголовка;",
            "по значению времени жизни ;",
            "по значению контрольной суммы заголовка и данных;"
        ],
        "correct": 2,
        type: "single",
        "explanation": "IP-дейтаграмма проверяется на наличие ошибок с помощью контрольной суммы (checksum), которая вычисляется только для заголовка IP-пакета (обычно длиной 20 байт). При получении каждый узел (маршрутизатор или конечный хост) вычисляет контрольную сумму заголовка заново и сравнивает её со значением в поле «Контрольная сумма заголовка». Если значения не совпадают, пакет отбрасывается. Данные (полезная нагрузка) не защищены IP-контрольной суммой — за их целостность отвечают протоколы более высоких уровней (например, TCP или UDP)."
    },

    {
        "question": "Широковещательная рассылка канального уровня - это :",
        "options": [
            "передача кадров, которые должны быть приняты определенной группой узлов локальной сети;",
            "передача кадров, которые должны быть приняты всеми узлами локальной сети;",
            "передача кадров, которые должны быть приняты всеми узлами глобальной сети;",
            "передача кадров, которые должны быть приняты всеми компьютерами одного подразделения;"
        ],
        "correct": 1,
        type: "single",
        "explanation": "Широковещательная рассылка (broadcast) на канальном уровне (уровень 2 модели OSI) — это передача кадра по сети, при которой все узлы, находящиеся в одном широковещательном домене (обычно в пределах одного сегмента локальной сети, ограниченного маршрутизаторами), обязаны принять и обработать этот кадр. Для этого используется специальный MAC-адрес получателя: FF:FF:FF:FF:FF:FF. Это отличается от групповой рассылки (multicast), предназначенной для определённой группы узлов."
    },

    {
        "question": "Могут ли на одном компьютере одновременно работать приложения с одинаковыми номерами портов ?",
        "options": [
            "могут, если приложения запущены от имени различных пользователей;",
            "могут, если приложения используют различные транспортные протоколы;",
            "могут, если приложения написаны на различных языках программирования;",
            "могут, если приложения используют различные канальные протоколы;",
            "не могут."
        ],
        "correct": 1,
        type: "single",
        "explanation": "Да, могут. Сокет (конечная точка сетевого соединения) однозначно определяется комбинацией: IP-адрес + номер порта + транспортный протокол. Поэтому два разных приложения могут одновременно использовать один и тот же номер порта, если они работают с разными транспортными протоколами (например, одно приложение слушает TCP-порт 53, а другое — UDP-порт 53). Это распространённая практика, например, для DNS-сервера. Также это возможно, если приложения используют разные IP-адреса (например, разные сетевые интерфейсы), но в данном вопросе такой вариант не указан."
    },

    {
        "question": "Размер окна протокола TCP определяет:",
        "options": [
            "максимальный размер сегмента, который может принять получатель;",
            "максимальный размер блока данных, который может передать отправитель;",
            "максимальный размер блока данных, который может передать отправитель без подтверждающей квитанции на получение предыдущего блока;",
            "максимальный размер заголовка в принятом сегменте;",
            "максимальный размер блока данных, который может передать отправитель с подтверждающей квитанцией на получение каждого сегмента;"
        ],
        "correct": 2,
        type: "single",
        "explanation": "Размер окна (Window Size) в TCP — это значение, указывающее объём данных (в байтах), который отправитель может передать без получения подтверждения (ACK) от получателя. Оно определяет текущую доступную ёмкость буфера получателя и используется для управления потоком данных (flow control) и предотвращения переполнения получателя. Это не максимальный размер сегмента (MSS), а именно количество байтов данных, которые можно отправить в полёт до необходимости ждать подтверждения."
    },

    {
        "question": "Какой тип адреса имеет каждый подключенный порт маршрутизатора ?",
        "options": [
            "только MAC-адрес",
            "только IP-адрес",
            "не имеет IP-адреса и MAC-адреса",
            "IP-адрес и MAC-адрес"
        ],
        "correct": 3,
        type: "single",
        "explanation": "Каждый активный порт (интерфейс) маршрутизатора, подключенный к сети (например, Ethernet), работает на канальном (L2) и сетевом (L3) уровнях. На канальном уровне ему требуется уникальный MAC-адрес для идентификации в рамках локального сегмента сети (например, для приёма и отправки кадров Ethernet). На сетевом уровне ему назначается IP-адрес, который идентифицирует данный интерфейс (и, следовательно, сеть) в IP-сетях. Таким образом, порт маршрутизатора имеет оба адреса."
    },

    {
        "question": "Верно ли, что сервер и клиент не могут выполняться на одном компьютере ?",
        "options": [
            "Верно",
            "Неверно"
        ],
        "correct": 1,
        type: "single",
        "explanation": "Неверно. Серверное и клиентское программное обеспечение вполне могут выполняться на одном физическом компьютере. Они взаимодействуют через интерфейс loopback (адрес 127.0.0.1 в IPv4 или ::1 в IPv6), который представляет виртуальный сетевой интерфейс, направляющий сетевой трафик обратно на тот же хост. Это стандартная практика для разработки, тестирования и работы многих приложений (например, веб-сервер и браузер на одной машине)."
    },

    {
        "question": "Какой стек протоколов из перечисленных используется в сети Internet ?",
        "options": [
            "IPX/SPX;",
            "TCP/UDP;",
            "TCP/IP;",
            "NetBIOS/SMB;"
        ],
        "correct": 2,
        type: "single",
        "explanation": "Основным и фундаментальным стеком протоколов, на котором построена глобальная сеть Интернет, является стек TCP/IP. Он включает в себя протоколы IP (Internet Protocol) для адресации и маршрутизации, TCP (Transmission Control Protocol) для надёжной передачи данных с установлением соединения, UDP (User Datagram Protocol) для быстрой передачи без установления соединения, а также множество других протоколов (ICMP, HTTP, DNS и т.д.). Вариант «TCP/UDP» не является полным стеком, это лишь транспортные протоколы, входящие в стек TCP/IP."
    },

    {
        "question": "Какие узлы получат пакет с IP-адресом 255.255.255.255 ?",
        "options": [
            "узел с адресом 255.255.255.255, находящийся в любой сети, подключенной к Интернету;",
            "все узлы, находящиеся в сети, которая имеет адрес 255.255.255.255 ;",
            "узел с адресом 255.255.255.255, находящийся в той же сети, что и отправитель;",
            "все узлы, подключенные к сети Интернет;",
            "все узлы, находящиеся в той же сети, что и отправитель;"
        ],
        "correct": 4,
        type: "single",
        "explanation": "IP-адрес 255.255.255.255 называется ограниченным широковещательным адресом (limited broadcast address). Пакет, отправленный на этот адрес, предназначен для всех узлов, находящихся в том же широковещательном домене (подсети), что и отправитель. Маршрутизаторы не пересылают такие пакеты за пределы локальной сети (подсети), ограничивая область распространения."
    },

    {
        "question": "Верно ли, что сокеты являются платформенно-независимыми объектами?",
        "options": [
            "Верно",
            "Неверно"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Тут хз ,смотря с какой стороны подойти (Надо уточнить в методе)"
    },

    {
        "question": "Укажите IP-адрес сети, в которой находится компьютер с адресом 25.41.5.18/10",
        "options": [
            "25.0.0.0",
            "25.41.0.0",
            "25.40.0.0",
            "25.41.5.0",
            "25.32.0.0"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Для нахождения адреса сети необходимо выполнить операцию логического И между IP-адресом (25.41.5.18) и маской подсети (/10 или 255.192.0.0). Маска /10 означает, что сетевой частью являются первые 10 бит. Применяя маску: 25 & 255 = 25, 41 & 192 = 0, 5 & 0 = 0, 18 & 0 = 0. Получаем адрес сети: 25.0.0.0."
    },

    {
        "question": "На каком уровне OSI проводится разбиение сообщения на фрагменты в приложении, использующем дейтаграммные сокеты ?",
        "options": [
            "транспортный",
            "физический",
            "сетевой",
            "канальный"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Дейтаграммные сокеты (например, использующие UDP) работают на транспортном уровне модели OSI. Именно на этом уровне приложение, использующее UDP, само определяет границы сообщений: каждый вызов sendto() отправляет одно законченное сообщение (дейтаграмму). В отличие от TCP (потоковые сокеты), который может «склеивать» или «разрезать» данные при передаче, UDP сохраняет границы сообщений, переданных приложением. Таким образом, разбиение на фрагменты (или определение их размера) происходит на уровне приложения, которое работает поверх транспортного уровня, но в контексте модели OSI ответственность за инкапсуляцию данных в дейтаграммы лежит на транспортном уровне."
    },

    {
        "question": "Как называется параметр протокола TCP, определяющий размер передаваемого сегмента данных ?",
        "options": [
            "MSS",
            "MTU",
            "Window Size",
            "TTL",
            "Checksum"
        ],
        "correct": 1,
        type: "single",
        "explanation": "Параметр, который непосредственно определяет максимальный размер полезных данных (без заголовков) в одном сегменте TCP, называется MSS (Maximum Segment Size). Однако MSS напрямую зависит от MTU (Maximum Transmission Unit) сетевого пути. MTU — это максимальный размер пакета, который может быть передан на канальном уровне без фрагментации. Так как в вопросе, возможно, подразумевается базовый определяющий фактор размера сегмента, ответ может быть MTU. В TCP сегмент формируется с учетом MTU пути, чтобы избежать фрагментации на сетевом уровне."
    },

    {
        "question": "Как реализуется передача ICMP-сообщения ?",
        "options": [
            "ICMP- сообщение инкапсулируется в поле данных сегмента TCP;",
            "ICMP- сообщение передается в виде специального кадра Ethernet;",
            "ICMP- сообщение инкапсулируется в поле данных IP-пакета;",
            "ICMP- сообщение инкапсулируется в поле данных кадра Ethernet;"
        ],
        "correct": 2,
        type: "single",
        "explanation": "ICMP (Internet Control Message Protocol) является неотъемлемой частью стека IP и работает непосредственно поверх сетевого уровня. ICMP-сообщение инкапсулируется (помещается) в поле данных IP-пакета, при этом в заголовке IP-пакета указывается протокол номер 1 (ICMP). Затем этот IP-пакет, в свою очередь, инкапсулируется в кадр канального уровня (например, Ethernet). ICMP не использует транспортные протоколы TCP или UDP."
    },

    {
        "question": "Введите число, соответствующее общему количеству сокетов, используемых в однопоточном сервере при проведении обмена с клиентом:",
        "options": [
            "1",
            "2",
            "3",
            "4",
            "5"
        ],
        "correct": 1,
        type: "single",
        "explanation": " "
    },

    {
        "question": "Верно ли, что обработка ICMP-сообщения входит в обязанности протоколов IP или ICMP ?",
        "options": [
            "Верно",
            "Неверно"
        ],
        "correct": 0,
        type: "single",
        "explanation": "Верно. ICMP (Internet Control Message Protocol) является вспомогательным протоколом для IP и предназначен для обмена служебной и диагностической информацией. Обработка ICMP-сообщений (например, эхо-запрос/ответ, сообщение об ошибке доставки, перенаправление маршрута и т.д.) является обязанностью либо реализации протокола IP (ядро операционной системы), либо отдельного модуля ICMP, который тесно интегрирован с IP-стеком. Эти протоколы работают на сетевом уровне и их обработка не входит в задачи прикладных или транспортных протоколов (таких как TCP или UDP)."
    },

    {
        "question": "Основные функции транспортного уровня модели OSI:",
        "options": [
            "определение маршрута передачи пакетов от одного узла сети к другому",
            "шифрование и дешифрование пакетов",
            "буферизация принимаемых пакетов",
            "упорядочение прибывших пакетов",
            "разбивка сообщения сеансового уровня на пакеты"
        ],
        "correct": [2, 3, 4], // Индексы c, d, e
        "type": "multiple",
        "explanation": "Основные функции транспортного уровня включают: управление потоком данных, обеспечение надежности передачи (упорядочение пакетов), сегментацию данных (разбивка сообщений), контроль ошибок и буферизацию. Определение маршрута - функция сетевого уровня, шифрование - функций презентационного уровня."
    },

    {
        "question": "При использовании статических MAC-адресов ...",
        "options": [
            "a. возможно уменьшение длины физического адреса.",
            "b. физические адреса назначаются изготовителем сетевого оборудования;",
            "c. возможны конфликты сетевых устройств;",
            "d. невозможны конфликты сетевых устройств;",
            "e. сетевое оборудование само назначает себе физические адреса;"
        ],
        "correct": [1, 3], 
        "type": "multiple",
        "explanation": " "
    },

    {
        "question": "Что происходит в сети в случае возникновения ошибки при прохождении IP-пакета, несущего ICMP-сообщение?",
        "options": [
            "a. пакет, несущий ICMP-сообщение, уничтожается;",
            "b. генерируется новый пакет с ICMP-сообщением, который передается всем узлам сетей, подключенных к маршрутизатору которая обнаружил ошибку;",
            "c. генерируется новый пакет с ICMP-сообщением, который передается узлу-отправителю исходного пакета с ICMP-сообщением;",
            "d. генерируется новый пакет с ICMP-сообщением, который передается всем узлам сети, маршрутизатор которой обнаружил ошибку;"
        ],
        "correct": [0], // Только вариант a
        "type": "multiple",
        "explanation": "Согласно RFC 792, ICMP-сообщения об ошибках НЕ генерируются в ответ на другие ICMP-сообщения об ошибках. Это предотвращает бесконечные цепочки ICMP-сообщений. Если возникает ошибка при передаче пакета с ICMP-сообщением, такой пакет просто отбрасывается (уничтожается) без генерации нового ICMP-сообщения."
    },

    {
        "question": "Укажите свойства составного канала:",
        "options": [
            "a. передача данных может проводиться со скоростью, превышающей пропускную способность составного канала;",
            "b. число элементарных каналов на маршруте передачи данных может изменяться;",
            "c. состоит из фиксированного числа элементарных каналов;",
            "d. имеет фиксированную пропускную способность;",
            "e. элементарные каналы, входящие в составной канал, во время сеанса связи работают в режиме разделения времени;",
            "f. данные гарантированно поступают адресату без потерь;"
        ],
        "correct": [0, 1], // Индексы a и b
        "type": "multiple",
        "explanation": "Составной канал (агрегированный канал) объединяет несколько физических каналов для увеличения пропускной способности и надежности. Свойства: a) можно достичь скорости выше пропускной способности отдельного канала, b) количество элементарных каналов может динамически меняться. Составной канал НЕ имеет фиксированного числа каналов, НЕ имеет фиксированной пропускной способности, каналы работают параллельно (не в режиме разделения времени), и НЕ гарантирует доставку без потерь."
    },

    {
        "question": "С какой целью не используется ARP - протокол?",
        "options": [
            "a. для определения MAC-адреса по доменному адресу;",
            "b. для определения IP - адреса по доменному адресу;",
            "c. для определения доменного адреса по IP - адресу;",
            "d. для определения IP - адреса по MAC-адресу;",
            "e. для определения MAC-адреса по IP - адресу;"
        ],
        "correct": [0, 1, 2, 3], // Индексы a, b, c, d
        "type": "multiple",
        "explanation": "ARP (Address Resolution Protocol) используется ТОЛЬКО для определения MAC-адреса по IP-адресу (вариант e). Он НЕ используется: a) для определения MAC-адреса по доменному имени (это DNS + ARP), b) для определения IP-адреса по доменному имени (это DNS), c) для определения доменного имени по IP-адресу (обратный DNS), d) для определения IP-адреса по MAC-адресу (обратный ARP или RARP, но не обычный ARP)."
    },

    {
        "question": "Сообщения каких протоколов могут инкапсулироваться в IP-пакет?",
        "options": [
            "a. UDP",
            "b. LLC",
            "c. TCP",
            "d. ARP",
            "e. ICMP"
        ],
        "correct": [0, 2, 4], // Индексы a, c, e
        "type": "multiple",
        "explanation": "В IP-пакет могут инкапсулироваться протоколы транспортного уровня (TCP, UDP) и сетевого уровня (ICMP, IGMP). UDP (a) и TCP (c) - транспортные протоколы, инкапсулируются в IP. ICMP (e) - протокол сетевого уровня, также инкапсулируется в IP. LLC (b) - подуровень канального уровня, не инкапсулируется в IP. ARP (d) - протокол канального уровня, работает независимо от IP и не инкапсулируется в IP-пакеты."
    },

    {
        "question": "Какие из указанных адресов являются частными (серыми)?",
        "options": [
            "a. 217.172.170.179",
            "b. 192.168.50.27",
            "c. 198.192.26.98",
            "d. 172.20.111.87",
            "e. 10.242.44.68"
        ],
        "correct": [1, 3, 4], // Индексы b, d, e
        "type": "multiple",
        "explanation": "Частные (серые) IP-адреса определены в RFC 1918 и не маршрутизируются в интернете. Диапазоны частных адресов: 10.0.0.0-10.255.255.255 (e), 172.16.0.0-172.31.255.255 (d), 192.168.0.0-192.168.255.255 (b). Адреса a (217.172.170.179) и c (198.192.26.98) являются публичными и маршрутизируются в глобальном интернете."
    },

    {
        "question": "Какая ситуация возникнет на однопоточном сервере в случае одновременного обращения к нему нескольких клиентов?",
        "options": [
            "a. будет выполняться запрос только одного клиента, остальные запросы будут поставлены в очередь;",
            "b. будет выполняться запрос только одного клиента, остальные запросы будут проигнорированы;",
            "c. на сервере возникнет ошибка, связанная с перегрузкой;",
            "d. будут выполняться одновременно запросы всех клиентов;",
            "e. будет выполняться запрос только одного клиента, остальные клиенты получат сообщение об ошибке;"
        ],
        "correct": [0], // Только вариант a
        "type": "multiple",
        "explanation": "Однопоточный сервер обрабатывает запросы последовательно. При одновременном обращении нескольких клиентов, операционная система ставит входящие соединения в очередь ожидания (listen backlog queue). Сервер будет обрабатывать запросы по одному в порядке поступления. Это стандартное поведение TCP/IP стека - соединения не теряются, а ожидают обработки в системной очереди."
    },

    {
        "question": "Коммутатор - это:",
        "options": [
            "a. устройство, которое используется для сокращения сетевого трафика путем анализа IP-адреса получателя;",
            "b. устройство, которое используется для сокращения сетевого трафика путем анализа MAC-адреса получателя;",
            "c. устройство, которое анализирует полученные кадры и направляет их конкретному адресату;",
            "d. устройство, которое анализирует полученные кадры и направляет их на все свои порты;"
        ],
        "correct": [1, 2], // Индексы b и c
        "type": "multiple",
        "explanation": "Коммутатор (switch) работает на канальном уровне (L2) модели OSI и анализирует MAC-адреса для сокращения сетевого трафика и направляет кадры только на нужный порт. b) Верно - анализирует MAC-адреса. c) Верно - направляет кадры конкретному адресату. a) Неверно - анализ IP-адресов выполняется маршрутизаторами (L3). d) Неверно - это описание хаба (концентратора), который ретранслирует кадры на все порты."
    },

    {
        "question": "Какие протоколы не применяют метод accept?",
        "options": [
            "a. UDP",
            "b. TCP",
            "c. Ethernet",
            "d. IPX",
            "e. IP"
        ],
        "correct": [0, 2, 3, 4], // Индексы a, c, d, e
        "type": "multiple",
        "explanation": "Метод accept() используется в сетевом программировании для принятия входящих соединений по протоколу TCP (b), который является соединенно-ориентированным. UDP (a) - дейтаграммный протокол без установления соединения, не использует accept. Ethernet (c), IPX (d) и IP (e) - протоколы нижних уровней, не имеют концепции соединений и методов accept на уровне приложений."
    },

    {
        "question": "Укажите компоненты службы DNS.",
        "options": [
            "a. DNS клиент;",
            "b. DNS сервер;",
            "c. DNS провайдер;",
            "d. DNS агент;",
            "e. DNS оператор;"
        ],
        "correct": [0, 1], // Индексы a и b
        "type": "multiple",
        "explanation": "Основные компоненты службы DNS: a) DNS-клиент (resolver) - отправляет запросы на преобразование имен, b) DNS-сервер - обрабатывает запросы и возвращает ответы. Термины 'DNS провайдер', 'DNS агент' и 'DNS оператор' не являются стандартными компонентами архитектуры DNS, а скорее ролями или службами, предоставляемыми организациями."
    },

    {
        "question": "Какие из перечисленных терминов определяют принципы функционирования современных сетей?",
        "options": [
            "a. коммутация портов;",
            "b. коммутация каналов;",
            "c. коммутация кадров;",
            "d. коммутация пакетов;",
            "e. коммутация фреймов;"
        ],
        "correct": [1,2,3,4], // Индексы c и d
        "type": "multiple",
        "explanation": "Тут хз."
    },

    {
        "question": "Повторитель - это:",
        "options": [
            "a. устройство, имеющее два и более портов, предназначенное для усиления входного сигнала;",
            "b. устройство, повторяющее входной сигнал и передающее его указанному адресату;",
            "c. устройство, имеющее два порта, предназначенное для усиления входного сигнала;",
            "d. устройство, повторяющее входной сигнал и передающее его в другую подсеть;"
        ],
        "correct": [0], // Индекс a
        "type": "multiple",
        "explanation": "Повторитель (repeater) - это сетевое устройство физического уровня (L1), которое усиливает и ретранслирует сигнал, увеличивая расстояние передачи. a) Верно - повторитель имеет два или более портов и усиливает сигнал. b) Неверно - повторитель не анализирует адреса, он передает сигнал на все порты. c) Частично верно, но ограничение 'два порта' не обязательно - могут быть многопортовые повторители. d) Неверно - передача в другую подсеть требует маршрутизации (уровень 3)."
    },

    {
        "question": "Какие действия выполняет маршрутизатор, если в таблице маршрутизации отсутствует адрес сети получателя IP-дейтаграммы и адрес по умолчанию?",
        "options": [
            "a. дейтаграмма передается на все порты маршрутизатора;",
            "b. отправителю передается ICMP-сообщение об ошибке;",
            "c. дейтаграмма отбрасывается;",
            "d. отправителю передается сообщение об ошибке DNS;",
            "e. дейтаграмма передается на все порты маршрутизатора, кроме порта получателя;"
        ],
        "correct": [2], // Индексы b и c
        "type": "multiple",
        "explanation": "Тут хз, возможно ещё (с)"
    },

    {
        "question": "Какие уровни модели OSI являются сетезависимыми?",
        "options": [
            "a. прикладной",
            "b. сеансовый",
            "c. транспортный",
            "d. представительный",
            "e. сетевой",
            "f. физический",
            "g. канальный"
        ],
        "correct": [4, 5, 6], // Индексы e, f, g
        "type": "multiple",
        "explanation": "Сетезависимые (нижние) уровни модели OSI: e) сетевой (L3), f) физический (L1), g) канальный (L2). Эти уровни зависят от конкретной сетевой технологии. Сетенезависимые (верхние) уровни: a) прикладной (L7), b) сеансовый (L5), c) транспортный (L4), d) представительный/presentation (L6) - работают независимо от физической сети."
    },

    {
        "question": "Что такое сетевой шторм?",
        "options": [
            "a. лавинообразное увеличение количества одновременно работающих пользователей;",
            "b. превышение максимального допустимого числа узлов сети;",
            "c. лавинообразное увеличение количества TCP-сегментов, передаваемых по сети;",
            "d. лавинообразное увеличение количества сообщений об ошибках, передаваемых по сети;"
        ],
        "correct": [3], // Индекс d
        "type": "multiple",
        "explanation": "Сетевой шторм - это ситуация, когда d) лавинообразно увеличивается количество широковещательных сообщений (не обязательно об ошибках), что приводит к перегрузке сети. Часто вызван петлями в топологии сети при отсутствии STP (Spanning Tree Protocol). a) неверно - связано с пользователями, а не с трафиком. b) неверно - это ограничение сети. c) неверно - TCP-сегменты обычно не вызывают штормов."
    },

    {
        "question": "Какие топологии сетей являются типовыми?",
        "options": [
            "a. звезда;",
            "b. общая шина;",
            "c. кольцо;",
            "d. гибридная",
            "e. иерархическая;"
        ],
        "correct": [0, 1, 2], // Индексы a, b, c
        "type": "multiple",
        "explanation": "Тремя основными типовыми топологиями сетей являются: a) звезда (star), b) общая шина (bus), c) кольцо (ring). d) гибридная и e) иерархическая являются комбинациями базовых топологий и не считаются основными типовыми топологиями."
    },

    {
        "question": "Служба DNS предназначена для:",
        "options": [
            "a. автоматического поиска IP-адреса по известному символьному имени узла;",
            "b. автоматического поиска символьного имени узла по его MAC-адресу;",
            "c. автоматического поиска символьного имени узла по его IP-адресу;",
            "d. автоматического поиска MAC-адреса по известному символьному имени узла;"
        ],
        "correct": [0, 2], // Индексы a и c
        "type": "multiple",
        "explanation": "DNS (Domain Name System) предназначена для: a) преобразования доменных имен в IP-адреса (прямой DNS-запрос), c) преобразования IP-адресов в доменные имена (обратный DNS-запрос). b) и d) неверно - преобразование MAC-адресов выполняется протоколом ARP (локально) и не связано с DNS."
    },

    {
        "question": "При использовании динамических MAC-адресов ...",
        "options": [
            "a. невозможны конфликты сетевых устройств;",
            "b. сетевое оборудование само назначает себе физические адреса;",
            "c. физические адреса назначаются изготовителем сетевого оборудования;",
            "d. возможны конфликты сетевых устройств;",
            "e. возможно уменьшение длины физического адреса."
        ],
        "correct": [1, 3], // Индексы b и d
        "type": "multiple",
        "explanation": "Динамические MAC-адреса: b) назначаются самим оборудованием или администратором (локально управляемые адреса), d) возможны конфликты при некорректной настройке. a) неверно - конфликты возможны. c) неверно - это характеристика статических адресов. e) неверно - длина MAC-адреса фиксирована (48 бит)."
    },

    {
        "question": "В программе сервера Вы задали для прослушивающего сокета адрес 192.168.0.4. Какие клиенты могут обратиться с запросом к этому серверу?",
        "options": [
            "a. клиенты, выполняющиеся на одном компьютере с сервером;",
            "b. клиенты, находящиеся вне локальной сети, к которой подключен сервер;",
            "c. клиенты, находящиеся на любых узлах глобальной сети;",
            "d. клиенты, находящиеся в локальной сети, к которой подключен сервер;"
        ],
        "correct": [0, 3], // Индексы a и d
        "type": "multiple",
        "explanation": "Если сервер привязан к конкретному IP-адресу 192.168.0.4 (частный адрес), то к нему могут подключиться: a) клиенты на том же компьютере (через loopback или этот же адрес), d) клиенты в той же локальной сети (той же подсети 192.168.0.0/24). b) и c) неверно - клиенты извне не могут подключиться напрямую к частному адресу 192.168.0.4 без NAT/проброса портов."
    },

    {
        "question": "Сокет - это:",
        "options": [
            "a. программный интерфейс для обеспечения обмена данными между процессами;",
            "b. абстрактный объект, используемый для обмена данными между оперативной и внешней памятью;",
            "c. абстрактный объект, реализующий некоторые функции сетевого уровня модели OSI;",
            "d. абстрактный объект, представляющий конечную точку соединения клиент-сервер;"
        ],
        "correct": [0, 3], // Индексы a и d
        "type": "multiple",
        "explanation": "Сокет - это: a) программный интерфейс (API) для сетевого взаимодействия между процессами, d) абстрактный объект, представляющий конечную точку сетевого соединения (комбинация IP-адрес + порт + протокол). b) неверно - это описание файлового ввода-вывода. c) неверно - сокеты работают на транспортном уровне и выше, а не на сетевом."
    },

    {
        "question": "Укажите основные функции канального уровня модели OSI:",
        "options": [
            "a. проверка доступности среды передачи данных;",
            "b. проводит доставку кадров адресату;",
            "c. обнаружение и коррекция ошибок;",
            "d. организует доставку кадров адресату в пределах сегмента сети, имеющего типовую топологию;",
            "e. кодирование данных;"
        ],
        "correct": [0, 1, 2, 3], // Индексы a, b, c, d
        "type": "multiple",
        "explanation": "Основные функции канального уровня (L2): a) управление доступом к среде (MAC, CSMA/CD), b) и d) доставка кадров адресату в пределах сегмента сети, c) обнаружение ошибок (CRC), коррекция через повторную передачу. e) кодирование данных - это функция физического уровня (L1), хотя некоторые протоколы L2 могут включать элементы кодирования."
    },

    {
        "question": "Какие данные могут содержаться в ответе DHCP-сервера DHCP-клиенту?",
        "options": [
            "a. IP-адрес DHCP-сервера",
            "b. IP-адрес узла-отправителя DHCP-запроса",
            "c. IP-адрес маршрутизатора по умолчанию",
            "d. IP-адрес коммутатора, к которому подключен отправитель DHCP-запроса",
            "e. IP-адреса серверов DNS"
        ],
        "correct": [0, 2, 4], // Индексы a, c, e
        "type": "multiple",
        "explanation": "В ответе DHCP-сервера (DHCPOFFER/DHCPACK) могут содержаться: a) IP-адрес DHCP-сервера (option 54), c) адрес шлюза по умолчанию (option 3), e) адреса DNS-серверов (option 6). b) неверно - клиент еще не имеет IP-адреса, он его получает. d) неверно - коммутаторы работают на L2 и не имеют IP-адресов на портах клиентов (кроме управляемых)."
    },

    {
        "question": "Укажите в числовом виде размер сетевого адреса протокола IPv6 в битах:",
        "options": [
            "32",
            "64",
            "128",
            "256",
            "48"
        ],
        "correct": 2, // Индекс 2 (128 бит)
        "type": "single",
        "explanation": "IPv6 использует 128-битные адреса, что в 4 раза больше, чем 32-битные адреса IPv4. Это позволяет создать примерно 3.4×10³⁸ уникальных адресов. IPv4 - 32 бита, MAC-адрес - 48 бит."
    },

    {
        "question": "Укажите в числовом виде количество IP-адресов маршрутизатора имеющего 8 рабочих портов",
        "options": [
            "8",
            "9",
            "1",
            "16",
            "4"
        ],
        "correct": 1, // Индекс 1 (9 адресов)
        "type": "single",
        "explanation": "Маршрутизатор с 8 рабочими портами имеет: 8 IP-адресов (по одному на каждый интерфейс/порт) + 1 дополнительный адрес для управления (loopback или management interface). Итого: 9 IP-адресов. В реальных конфигурациях каждый физический порт получает свой IP-адрес для работы в соответствующей подсети."
    },

    {
        "question": "Какая кодировка символов используется протоколом DNS для русскоязычных доменных имен?",
        "options": [
            "a. Unicode",
            "b. UTF-8",
            "c. ANSI",
            "d. Punycode",
            "e. ASCII"
        ],
        "correct": 3, // Индекс 3 (Punycode)
        "type": "single",
        "explanation": "Для интернационализированных доменных имен (IDN), включая русскоязычные, используется кодировка Punycode. Она преобразует Unicode-символы в ASCII-совместимую форму (ACE - ASCII Compatible Encoding), что позволяет использовать домены с национальными символами в существующей инфраструктуре DNS. Пример: домен 'россия.рф' кодируется как 'xn--h1alffa9f.xn--p1ai'."
    },

    {
        "question": "Сколько буферов имеет TCP-сокет?",
        "options": [
            "1",
            "2",
            "3",
            "4",
            "0"
        ],
        "correct": 1, // Индекс 1 (2 буфера)
        "type": "single",
        "explanation": "TCP-сокет имеет 2 буфера: входной (receive buffer) и выходной (send buffer). Входной буфер хранит данные, полученные от удаленного узла, но еще не прочитанные приложением. Выходной буфер хранит данные, отправленные приложением, но еще не переданные по сети или не подтвержденные получателем."
    },

    {
        "question": "Размер скользящего окна TCP определяет ...",
        "options": [
            "a. размер TCP-сегмента",
            "b. размер буфера приема",
            "c. размер буфера отправления",
            "d. размер буфера копий"
        ],
        "correct": 1, // Индекс 1 (размер буфера приема)
        "type": "single",
        "explanation": "Размер скользящего окна (window size) в TCP определяет количество данных (в байтах), которое может быть принято без подтверждения. Это фактически соответствует доступному размеру буфера приема на стороне получателя. Окно 'скользит' по мере получения подтверждений, позволяя передавать новые данные."
    },

    {
        "question": "Укажите название протокола, на основе которого работает команда nslookup:",
        "options": [
            "DNS",
            "HTTP",
            "FTP",
            "SMTP",
            "ARP"
        ],
        "correct": 0, // Индекс 0 (DNS)
        "type": "single",
        "explanation": "Команда nslookup работает на основе протокола DNS (Domain Name System). Она используется для запроса DNS-серверов с целью получения информации о доменных именах, IP-адресах, записях MX, NS и других DNS-записях. nslookup отправляет DNS-запросы и отображает полученные ответы от DNS-серверов."
    },

    {
        "question": "Укажите свойства заголовка SNAP:",
        "options": [
            "a. два первые байта имеют значения 'AA';",
            "b. имеет размер 6 байтов;",
            "c. имеет размер 5 байтов;",
            "d. содержит код типа содержимого кадра;",
            "e. содержит код организации по стандартизации;",
            "f. имеет размер 8 байтов;",
            "g. не содержит код организации по стандартизации;"
        ],
        "correct": [0, 2, 3, 4], // Индексы a, c, d, e
        "type": "multiple",
        "explanation": "SNAP (Subnetwork Access Protocol) заголовок: a) начинается с 0xAA-AA (2 байта), c) имеет размер 5 байт (2 байта AA-AA + 3 байта OUI), d) содержит Type поле (2 байта) для типа протокола, e) содержит OUI (Organizationally Unique Identifier, 3 байта). b) и f) неверно - размер 5 байт. g) неверно - содержит OUI."
    }
   
];

// Массив вопросов (оставьте ваш существующий массив questions здесь)

let isReversedOrder = false;
let currentQuestion = 0;
let score = 0;
let userAnswers = [];
const shuffledQuestions = [...questions].sort(() => Math.random() - 0.5);

// Функция для проверки правильности ответа
function isAnswerCorrect(userAnswer, correctAnswer, questionType) {
    if (questionType === "multiple") {
        // Для вопросов с несколькими ответами
        if (!Array.isArray(userAnswer) || !Array.isArray(correctAnswer)) {
            return false;
        }

        // Сравниваем массивы (порядок не важен)
        if (userAnswer.length !== correctAnswer.length) {
            return false;
        }

        // Сортируем и сравниваем
        const sortedUser = [...userAnswer].sort((a, b) => a - b);
        const sortedCorrect = [...correctAnswer].sort((a, b) => a - b);

        return sortedUser.every((value, index) => value === sortedCorrect[index]);
    } else {
        // Для вопросов с одним ответом
        return userAnswer === correctAnswer;
    }
}

function resetReverseButton() {
    const reverseOrderBtn = document.getElementById("reverse-order-btn");
    const newBtn = reverseOrderBtn.cloneNode(true);
    reverseOrderBtn.parentNode.replaceChild(newBtn, reverseOrderBtn);
    return newBtn;
}

function showQuestion() {
    const questionElement = document.getElementById("question");
    const optionsElement = document.getElementById("options");
    const nextButton = document.getElementById("next-btn");
    const questionCounter = document.getElementById("question-counter");
    const scoreElement = document.getElementById("score");

    if (currentQuestion >= shuffledQuestions.length) {
        showResult();
        return;
    }

    const question = shuffledQuestions[currentQuestion];
    questionElement.textContent = question.question;
    optionsElement.innerHTML = "";
    nextButton.classList.add("hidden");

    questionCounter.textContent = `Вопрос ${currentQuestion + 1} из ${shuffledQuestions.length}`;
    scoreElement.textContent = `Счет: ${score}`;

    // Удаляем предыдущую подсказку, если есть
    const existingHint = document.querySelector(".multiple-hint");
    if (existingHint) {
        existingHint.remove();
    }

    // Добавляем подсказку для вопросов с несколькими ответами
    if (question.type === "multiple") {
        const hint = document.createElement("div");
        hint.classList.add("multiple-hint");
        hint.textContent = "(Выберите все правильные ответы)";
        questionElement.parentNode.insertBefore(hint, optionsElement);
    }

    // Очищаем предыдущий ответ
    userAnswers[currentQuestion] = question.type === "multiple" ? [] : null;

    question.options.forEach((option, index) => {
        const optionElement = document.createElement("div");
        optionElement.classList.add("option");

        // Определяем тип input в зависимости от типа вопроса
        const inputType = question.type === "multiple" ? "checkbox" : "radio";
        const inputName = question.type === "multiple" ? `answer-${currentQuestion}` : "answer";

        optionElement.innerHTML = `
            <input type="${inputType}" name="${inputName}" id="option-${currentQuestion}-${index}" value="${index}">
            <label for="option-${currentQuestion}-${index}">${option}</label>
        `;

        const inputElement = optionElement.querySelector("input");

        inputElement.addEventListener("change", (e) => {
            if (question.type === "multiple") {
                // Для вопросов с несколькими ответами
                if (!userAnswers[currentQuestion]) {
                    userAnswers[currentQuestion] = [];
                }

                if (e.target.checked) {
                    userAnswers[currentQuestion].push(index);
                } else {
                    const idx = userAnswers[currentQuestion].indexOf(index);
                    if (idx > -1) {
                        userAnswers[currentQuestion].splice(idx, 1);
                    }
                }

                // Показываем кнопку "Следующий" если есть хотя бы один ответ
                nextButton.classList.toggle("hidden", userAnswers[currentQuestion].length === 0);
            } else {
                // Для вопросов с одним ответом
                if (e.target.checked) {
                    userAnswers[currentQuestion] = index;
                    nextButton.classList.remove("hidden");
                }
            }
        });

        optionsElement.appendChild(optionElement);
    });
}

function showPreviewResult() {
    const questionContainer = document.getElementById("question-container");
    const nextButton = document.getElementById("next-btn");
    const resultElement = document.getElementById("result");
    const finalScoreElement = document.getElementById("final-score");
    const totalQuestionsElement = document.getElementById("total-questions");
    const percentageElement = document.getElementById("percentage");

    questionContainer.classList.add("hidden");
    nextButton.classList.add("hidden");
    resultElement.classList.remove("hidden");

    const answeredQuestions = userAnswers.filter(answer =>
        answer !== undefined && answer !== null &&
        (!Array.isArray(answer) || answer.length > 0)
    ).length;

    const currentScore = userAnswers.reduce((acc, answer, index) => {
        const question = shuffledQuestions[index];
        if (answer !== undefined && answer !== null &&
            (!Array.isArray(answer) || answer.length > 0)) {
            if (isAnswerCorrect(answer, question.correct, question.type)) {
                return acc + 1;
            }
        }
        return acc;
    }, 0);

    finalScoreElement.textContent = currentScore;
    totalQuestionsElement.textContent = answeredQuestions;
    percentageElement.textContent = answeredQuestions > 0 ? Math.round((currentScore / answeredQuestions) * 100) : 0;

    // Сбрасываем обработчики кнопки
    const reverseOrderBtn = resetReverseButton();
    reverseOrderBtn.textContent = "Показать в обратном порядке";
    reverseOrderBtn.addEventListener("click", () => {
        isReversedOrder = !isReversedOrder;
        reverseOrderBtn.textContent = isReversedOrder
            ? "Показать в обычном порядке"
            : "Показать в обратном порядке";
        renderAnswersList();
    });

    function renderAnswersList() {
        const answersContainer = document.getElementById("answers-container");
        answersContainer.innerHTML = "";

        const answersList = document.createElement("div");
        answersList.classList.add("answers-list");

        let displayQuestions = [...shuffledQuestions];

        if (isReversedOrder) {
            displayQuestions = [...shuffledQuestions].reverse();
        }

        displayQuestions.forEach((q, i) => {
            const originalIndex = shuffledQuestions.indexOf(q);
            const userAnswer = userAnswers[originalIndex];

            // Проверяем, есть ли ответ на этот вопрос
            const hasAnswer = userAnswer !== undefined && userAnswer !== null &&
                (!Array.isArray(userAnswer) || userAnswer.length > 0);

            if (hasAnswer) {
                const answerItem = document.createElement("div");
                answerItem.classList.add("answer-item");
                const isCorrect = isAnswerCorrect(userAnswer, q.correct, q.type);

                // Формируем текст ответа пользователя
                let userAnswerText = "";
                if (Array.isArray(userAnswer)) {
                    userAnswerText = userAnswer.map(idx => q.options[idx]).join(", ");
                } else {
                    userAnswerText = q.options[userAnswer] || 'Нет ответа';
                }

                // Формируем текст правильного ответа
                let correctAnswerText = "";
                if (Array.isArray(q.correct)) {
                    correctAnswerText = q.correct.map(idx => q.options[idx]).join(", ");
                } else {
                    correctAnswerText = q.options[q.correct];
                }

                answerItem.innerHTML = `
                    <p><strong>Вопрос ${originalIndex + 1}:</strong> ${q.question}</p>
                    <p class="${isCorrect ? 'correct' : 'incorrect'}">
                        Ваш ответ: ${userAnswerText}
                        ${isCorrect ? '✓' : `✗ (Правильный: ${correctAnswerText})`}
                    </p>
                    ${q.explanation ? `<p class="explanation">Пояснение: ${q.explanation}</p>` : ''}
                `;
                answersList.appendChild(answerItem);
            }
        });

        answersContainer.appendChild(answersList);
    }

    renderAnswersList();

    const restartBtn = document.getElementById("restart-btn");
    restartBtn.textContent = "Продолжить тест";
    restartBtn.addEventListener("click", () => {
        resultElement.classList.add("hidden");
        questionContainer.classList.remove("hidden");
        showQuestion();
    }, { once: true });
}

function showResult() {
    const questionContainer = document.getElementById("question-container");
    const nextButton = document.getElementById("next-btn");
    const resultElement = document.getElementById("result");
    const finalScoreElement = document.getElementById("final-score");
    const totalQuestionsElement = document.getElementById("total-questions");
    const percentageElement = document.getElementById("percentage");

    questionContainer.classList.add("hidden");
    nextButton.classList.add("hidden");
    resultElement.classList.remove("hidden");

    // Подсчет финального счета
    const finalScore = userAnswers.reduce((acc, answer, index) => {
        const question = shuffledQuestions[index];
        if (isAnswerCorrect(answer, question.correct, question.type)) {
            return acc + 1;
        }
        return acc;
    }, 0);

    finalScoreElement.textContent = finalScore;
    totalQuestionsElement.textContent = shuffledQuestions.length;
    percentageElement.textContent = Math.round((finalScore / shuffledQuestions.length) * 100);

    // Сбрасываем обработчики кнопки
    const reverseOrderBtn = resetReverseButton();
    reverseOrderBtn.textContent = "Показать в обратном порядке";
    reverseOrderBtn.addEventListener("click", () => {
        isReversedOrder = !isReversedOrder;
        reverseOrderBtn.textContent = isReversedOrder
            ? "Показать в обычном порядке"
            : "Показать в обратном порядке";
        renderAnswersList();
    });

    function renderAnswersList() {
        const answersContainer = document.getElementById("answers-container");
        answersContainer.innerHTML = "";

        const answersList = document.createElement("div");
        answersList.classList.add("answers-list");

        let indices = [];
        for (let i = 0; i < shuffledQuestions.length; i++) {
            indices.push(i);
        }

        if (isReversedOrder) {
            indices = indices.reverse();
        }

        indices.forEach(index => {
            const q = shuffledQuestions[index];
            const answerItem = document.createElement("div");
            answerItem.classList.add("answer-item");
            const userAnswer = userAnswers[index];
            const isCorrect = isAnswerCorrect(userAnswer, q.correct, q.type);

            // Формируем текст ответа пользователя
            let userAnswerText = "";
            if (Array.isArray(userAnswer)) {
                userAnswerText = userAnswer.map(idx => q.options[idx]).join(", ");
            } else {
                userAnswerText = q.options[userAnswer] || 'Нет ответа';
            }

            // Формируем текст правильного ответа
            let correctAnswerText = "";
            if (Array.isArray(q.correct)) {
                correctAnswerText = q.correct.map(idx => q.options[idx]).join(", ");
            } else {
                correctAnswerText = q.options[q.correct];
            }

            answerItem.innerHTML = `
                <p><strong>Вопрос ${index + 1}:</strong> ${q.question}</p>
                <p class="${isCorrect ? 'correct' : 'incorrect'}">
                    Ваш ответ: ${userAnswerText}
                    ${isCorrect ? '✓' : `✗ (Правильный: ${correctAnswerText})`}
                </p>
                ${q.explanation ? `<p class="explanation">Пояснение: ${q.explanation}</p>` : ''}
            `;
            answersList.appendChild(answerItem);
        });

        answersContainer.appendChild(answersList);
    }

    renderAnswersList();

    const restartBtn = document.getElementById("restart-btn");
    restartBtn.textContent = "Начать тест заново";
    restartBtn.addEventListener("click", () => {
        currentQuestion = 0;
        score = 0;
        userAnswers = [];
        isReversedOrder = false;
        shuffledQuestions.sort(() => Math.random() - 0.5);
        questionContainer.classList.remove("hidden");
        resultElement.classList.add("hidden");
        showQuestion();
    });
}

// Инициализация
document.getElementById("preview-btn").addEventListener("click", showPreviewResult);
document.getElementById("next-btn").addEventListener("click", () => {
    const currentQ = shuffledQuestions[currentQuestion];
    const userAnswer = userAnswers[currentQuestion];

    if (isAnswerCorrect(userAnswer, currentQ.correct, currentQ.type)) {
        score++;
    }

    currentQuestion++;
    showQuestion();
});

showQuestion();